(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{530:function(e,t,r){"use strict";r.r(t);var a=r(54),v=Object(a.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"四、路由"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#四、路由"}},[e._v("#")]),e._v(" 四、路由")]),e._v(" "),r("h2",{attrs:{id:"_1-vue-router-的懒加载如何实现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-vue-router-的懒加载如何实现"}},[e._v("#")]),e._v(" 1. Vue-Router 的懒加载如何实现")]),e._v(" "),r("p",[e._v("非懒加载：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("import List from '@/components/list.vue'\nconst router = new VueRouter({\n  routes: [\n    { path: '/list', component: List }\n  ]\n})\n")])])]),r("p",[e._v("（1）方案一(常用)：使用箭头函数+import动态加载")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const List = () => import('@/components/list.vue')\nconst router = new VueRouter({\n  routes: [\n    { path: '/list', component: List }\n  ]\n})\n")])])]),r("p",[e._v("（2）方案二：使用箭头函数+require动态加载")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const router = new Router({\n  routes: [\n   {\n     path: '/list',\n     component: resolve => require(['@/components/list'], resolve)\n   }\n  ]\n})\n")])])]),r("p",[e._v("（3）方案三：使用webpack的require.ensure技术，也可以实现按需加载。 这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// r就是resolve\nconst List = r => require.ensure([], () => r(require('@/components/list')), 'list');\n// 路由也是正常的写法  这种是官方推荐的写的 按模块划分懒加载 \nconst router = new Router({\n  routes: [\n  {\n    path: '/list',\n    component: List,\n    name: 'list'\n  }\n ]\n}))\n")])])]),r("h2",{attrs:{id:"_2-路由的hash和history模式的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-路由的hash和history模式的区别"}},[e._v("#")]),e._v(" 2. 路由的hash和history模式的区别")]),e._v(" "),r("p",[e._v("Vue-Router有两种模式："),r("strong",[e._v("hash模式")]),e._v("和"),r("strong",[e._v("history模式")]),e._v("。默认的路由模式是hash模式。")]),e._v(" "),r("h2",{attrs:{id:"_1-hash模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-hash模式"}},[e._v("#")]),e._v(" 1. hash模式")]),e._v(" "),r("p",[r("strong",[e._v("简介：")]),e._v(" hash模式是开发中默认的模式，它的URL带着一个#，例如：http://www.abc.com/#/vue，它的hash值就是"),r("code",[e._v("#/vue")]),e._v("。")]),e._v(" "),r("p",[r("strong",[e._v("特点")]),e._v("：hash值会出现在URL里面，但是不会出现在HTTP请求中，对后端完全没有影响。所以改变hash值，不会重新加载页面。这种模式的浏览器支持度很好，低版本的IE浏览器也支持这种模式。hash路由被称为是前端路由，已经成为SPA（单页面应用）的标配。")]),e._v(" "),r("p",[r("strong",[e._v("原理：")]),e._v(" hash模式的主要原理就是"),r("strong",[e._v("onhashchange()事件")]),e._v("：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("window.onhashchange = function(event){\n    console.log(event.oldURL, event.newURL);\n    let hash = location.hash.slice(1);\n}\n")])])]),r("p",[e._v("使用onhashchange()事件的好处就是，在页面的hash值发生变化时，无需向后端发起请求，window就可以监听事件的改变，并按规则加载相应的代码。除此之外，hash值变化对应的URL都会被浏览器记录下来，这样浏览器就能实现页面的前进和后退。虽然是没有请求后端服务器，但是页面的hash值和对应的URL关联起来了。")]),e._v(" "),r("h2",{attrs:{id:"_2-history模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-history模式"}},[e._v("#")]),e._v(" 2. history模式")]),e._v(" "),r("p",[r("strong",[e._v("简介：")]),e._v(" history模式的URL中没有#，它使用的是传统的路由分发模式，即用户在输入一个URL时，服务器会接收这个请求，并解析这个URL，然后做出相应的逻辑处理。")]),e._v(" "),r("p",[r("strong",[e._v("特点：")]),e._v(" 当使用history模式时，URL就像这样：http://abc.com/user/id。相比hash模式更加好看。但是，history模式需要后台配置支持。如果后台没有正确配置，访问时会返回404。")]),e._v(" "),r("p",[r("strong",[e._v("API：")]),e._v(" history api可以分为两大部分，切换历史状态和修改历史状态：")]),e._v(" "),r("ul",[r("li",[r("strong",[e._v("修改历史状态")]),e._v("：包括了 HTML5 History Interface 中新增的 "),r("code",[e._v("pushState()")]),e._v(" 和 "),r("code",[e._v("replaceState()")]),e._v(" 方法，这两个方法应用于浏览器的历史记录栈，提供了对历史记录进行修改的功能。只是当他们进行修改时，虽然修改了url，但浏览器不会立即向后端发送请求。如果要做到改变url但又不刷新页面的效果，就需要前端用上这两个API。")]),e._v(" "),r("li",[r("strong",[e._v("切换历史状态：")]),e._v(" 包括"),r("code",[e._v("forward()")]),e._v("、"),r("code",[e._v("back()")]),e._v("、"),r("code",[e._v("go()")]),e._v("三个方法，对应浏览器的前进，后退，跳转操作。")])]),e._v(" "),r("p",[e._v("虽然history模式丢弃了丑陋的#。但是，它也有自己的缺点，就是在刷新页面的时候，如果没有相应的路由或资源，就会刷出404来。")]),e._v(" "),r("p",[e._v("如果想要切换到history模式，就要进行以下配置（后端也要进行配置）：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const router = new VueRouter({\n  mode: 'history',\n  routes: [...]\n})\n")])])]),r("h2",{attrs:{id:"_3-两种模式对比"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-两种模式对比"}},[e._v("#")]),e._v(" 3. 两种模式对比")]),e._v(" "),r("p",[e._v("调用 history.pushState() 相比于直接修改 hash，存在以下优势:")]),e._v(" "),r("ul",[r("li",[e._v("pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的 URL；")]),e._v(" "),r("li",[e._v("pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中；")]),e._v(" "),r("li",[e._v("pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中；而 hash 只可添加短字符串；")]),e._v(" "),r("li",[e._v("pushState() 可额外设置 title 属性供后续使用。")]),e._v(" "),r("li",[e._v("hash模式下，仅hash符号之前的url会被包含在请求中，后端如果没有做到对路由的全覆盖，也不会返回404错误；history模式下，前端的url必须和实际向后端发起请求的url一致，如果没有对用的路由处理，将返回404错误。")])]),e._v(" "),r("p",[e._v("hash模式和history模式都有各自的优势和缺陷，还是要根据实际情况选择性的使用。")]),e._v(" "),r("h2",{attrs:{id:"_3-如何获取页面的hash变化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-如何获取页面的hash变化"}},[e._v("#")]),e._v(" 3. 如何获取页面的hash变化")]),e._v(" "),r("p",[r("strong",[e._v("（1）监听$route的变化")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// 监听,当路由发生变化的时候执行\nwatch: {\n  $route: {\n    handler: function(val, oldVal){\n      console.log(val);\n    },\n    // 深度观察监听\n    deep: true\n  }\n},\n")])])]),r("p",[r("strong",[e._v("（2）window.location.hash读取#值")])]),e._v(" "),r("p",[e._v("window.location.hash 的值可读可写，读取来判断状态是否改变，写入时可以在不重载网页的前提下，添加一条历史访问记录。")]),e._v(" "),r("h2",{attrs:{id:"_4-route-和-router-的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-route-和-router-的区别"}},[e._v("#")]),e._v(" 4. $route 和$router 的区别")]),e._v(" "),r("ul",[r("li",[e._v("$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数")]),e._v(" "),r("li",[e._v("$router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。")])]),e._v(" "),r("h2",{attrs:{id:"_5-如何定义动态路由-如何获取传过来的动态参数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-如何定义动态路由-如何获取传过来的动态参数"}},[e._v("#")]),e._v(" 5. 如何定义动态路由？如何获取传过来的动态参数？")]),e._v(" "),r("p",[r("strong",[e._v("（1）param方式")])]),e._v(" "),r("ul",[r("li",[e._v("配置路由格式："),r("code",[e._v("/router/:id")])]),e._v(" "),r("li",[e._v("传递的方式：在path后面跟上对应的值")]),e._v(" "),r("li",[e._v("传递后形成的路径："),r("code",[e._v("/router/123")])])]),e._v(" "),r("p",[e._v("1）路由定义")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("//在APP.vue中\n<router-link :to=\"'/user/'+userId\" replace>用户</router-link>    \n\n//在index.js\n{\n   path: '/user/:userid',\n   component: User,\n},\n")])])]),r("p",[e._v("2）路由跳转")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// 方法1：\n<router-link :to=\"{ name: 'users', params: { uname: wade }}\">按钮</router-link\n\n// 方法2：\nthis.$router.push({name:'users',params:{uname:wade}})\n\n// 方法3：\nthis.$router.push('/user/' + wade)\n")])])]),r("p",[e._v("3）参数获取")]),e._v(" "),r("p",[e._v("通过 "),r("code",[e._v("$route.params.userid")]),e._v(" 获取传递的值")]),e._v(" "),r("p",[r("strong",[e._v("（2）query方式")])]),e._v(" "),r("ul",[r("li",[e._v("配置路由格式："),r("code",[e._v("/router")]),e._v("，也就是普通配置")]),e._v(" "),r("li",[e._v("传递的方式：对象中使用query的key作为传递方式")]),e._v(" "),r("li",[e._v("传递后形成的路径："),r("code",[e._v("/route?id=123")])])]),e._v(" "),r("p",[e._v("1）路由定义")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('//方式1：直接在router-link 标签上以对象的形式\n<router-link :to="{path:\'/profile\',query:{name:\'why\',age:28,height:188}}">档案</router-link>\n\n// 方式2：写成按钮以点击事件形式\n<button @click=\'profileClick\'>我的</button>    \n\nprofileClick(){\n  this.$router.push({\n    path: "/profile",\n    query: {\n        name: "kobi",\n        age: "28",\n        height: 198\n    }\n  });\n}\n')])])]),r("p",[e._v("2）跳转方法")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// 方法1：\n<router-link :to=\"{ name: 'users', query: { uname: james }}\">按钮</router-link>\n\n// 方法2：\nthis.$router.push({ name: 'users', query:{ uname:james }})\n\n// 方法3：\n<router-link :to=\"{ path: '/user', query: { uname:james }}\">按钮</router-link>\n\n// 方法4：\nthis.$router.push({ path: '/user', query:{ uname:james }})\n\n// 方法5：\nthis.$router.push('/user?uname=' + jsmes)\n")])])]),r("p",[e._v("3）获取参数")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("通过$route.query 获取传递的值\n")])])]),r("h2",{attrs:{id:"_6-vue-router-路由钩子在生命周期的体现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6-vue-router-路由钩子在生命周期的体现"}},[e._v("#")]),e._v(" 6. Vue-router 路由钩子在生命周期的体现")]),e._v(" "),r("p",[e._v("一、Vue-Router导航守卫")]),e._v(" "),r("p",[e._v("有的时候，需要通过路由来进行一些操作，比如最常见的登录权限验证，当用户满足条件时，才让其进入导航，否则就取消跳转，并跳到登录页面让其登录。")]),e._v(" "),r("p",[e._v("为此有很多种方法可以植入路由的导航过程：全局的，单个路由独享的，或者组件级的")]),e._v(" "),r("ol",[r("li",[e._v("全局路由钩子")])]),e._v(" "),r("p",[e._v("vue-router全局有三个路由钩子;")]),e._v(" "),r("ul",[r("li",[e._v("router.beforeEach 全局前置守卫 进入路由之前")]),e._v(" "),r("li",[e._v("router.beforeResolve 全局解析守卫（2.5.0+）在 beforeRouteEnter 调用之后调用")]),e._v(" "),r("li",[e._v("router.afterEach 全局后置钩子 进入路由之后")])]),e._v(" "),r("p",[e._v("具体使用∶")]),e._v(" "),r("ul",[r("li",[e._v("beforeEach（判断是否登录了，没登录就跳转到登录页）")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("router.beforeEach((to, from, next) => {  \n    let ifInfo = Vue.prototype.$common.getSession('userData');  // 判断是否登录的存储信息\n    if (!ifInfo) { \n        // sessionStorage里没有储存user信息    \n        if (to.path == '/') { \n            //如果是登录页面路径，就直接next()      \n            next();    \n        } else { \n            //不然就跳转到登录      \n            Message.warning(\"请重新登录！\");     \n            window.location.href = Vue.prototype.$loginUrl;    \n        }  \n    } else {    \n        return next();  \n    }\n})\n")])])]),r("ul",[r("li",[e._v("afterEach （跳转之后滚动条回到顶部）")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("router.afterEach((to, from) => {  \n    // 跳转之后滚动条回到顶部  \n    window.scrollTo(0,0);\n});\n")])])]),r("ol",[r("li",[e._v("单个路由独享钩子")])]),e._v(" "),r("p",[r("strong",[e._v("beforeEnter")])]),e._v(" "),r("p",[e._v("如果不想全局配置守卫的话，可以为某些路由单独配置守卫，有三个参数∶ to、from、next")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("export default [    \n    {        \n        path: '/',        \n        name: 'login',        \n        component: login,        \n        beforeEnter: (to, from, next) => {          \n            console.log('即将进入登录页面')          \n            next()        \n        }    \n    }\n]\n")])])]),r("ol",[r("li",[e._v("组件内钩子")])]),e._v(" "),r("p",[e._v("beforeRouteUpdate、beforeRouteEnter、beforeRouteLeave")]),e._v(" "),r("p",[e._v("这三个钩子都有三个参数∶to、from、next")]),e._v(" "),r("ul",[r("li",[e._v("beforeRouteEnter∶ 进入组件前触发")]),e._v(" "),r("li",[e._v("beforeRouteUpdate∶ 当前地址改变并且改组件被复用时触发，举例来说，带有动态参数的路径foo/∶id，在 /foo/1 和 /foo/2 之间跳转的时候，由于会渲染同样的foa组件，这个钩子在这种情况下就会被调用")]),e._v(" "),r("li",[e._v("beforeRouteLeave∶ 离开组件被调用")])]),e._v(" "),r("p",[e._v("注意点，beforeRouteEnter组件内还访问不到this，因为该守卫执行前组件实例还没有被创建，需要传一个回调给 next来访问，例如：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("beforeRouteEnter(to, from, next) {      \n    next(target => {        \n        if (from.path == '/classProcess') {          \n            target.isFromProcess = true        \n        }      \n    })    \n}\n")])])]),r("p",[e._v("二、Vue路由钩子在生命周期函数的体现")]),e._v(" "),r("ol",[r("li",[e._v("完整的路由导航解析流程（不包括其他生命周期）")])]),e._v(" "),r("ul",[r("li",[e._v("触发进入其他路由。")]),e._v(" "),r("li",[e._v("调用要离开路由的组件守卫beforeRouteLeave")]),e._v(" "),r("li",[e._v("调用局前置守卫∶ beforeEach")]),e._v(" "),r("li",[e._v("在重用的组件里调用 beforeRouteUpdate")]),e._v(" "),r("li",[e._v("调用路由独享守卫 beforeEnter。")]),e._v(" "),r("li",[e._v("解析异步路由组件。")]),e._v(" "),r("li",[e._v("在将要进入的路由组件中调用 beforeRouteEnter")]),e._v(" "),r("li",[e._v("调用全局解析守卫 beforeResolve")]),e._v(" "),r("li",[e._v("导航被确认。")]),e._v(" "),r("li",[e._v("调用全局后置钩子的 afterEach 钩子。")]),e._v(" "),r("li",[e._v("触发DOM更新（mounted）。")]),e._v(" "),r("li",[e._v("执行beforeRouteEnter 守卫中传给 next 的回调函数")])]),e._v(" "),r("ol",[r("li",[e._v("触发钩子的完整顺序")])]),e._v(" "),r("p",[e._v("路由导航、keep-alive、和组件生命周期钩子结合起来的，触发顺序，假设是从a组件离开，第一次进入b组件∶")]),e._v(" "),r("ul",[r("li",[e._v("beforeRouteLeave：路由组件的组件离开路由前钩子，可取消路由离开。")]),e._v(" "),r("li",[e._v("beforeEach：路由全局前置守卫，可用于登录验证、全局路由loading等。")]),e._v(" "),r("li",[e._v("beforeEnter：路由独享守卫")]),e._v(" "),r("li",[e._v("beforeRouteEnter：路由组件的组件进入路由前钩子。")]),e._v(" "),r("li",[e._v("beforeResolve：路由全局解析守卫")]),e._v(" "),r("li",[e._v("afterEach：路由全局后置钩子")]),e._v(" "),r("li",[e._v("beforeCreate：组件生命周期，不能访问tAis。")]),e._v(" "),r("li",[e._v("created;组件生命周期，可以访问tAis，不能访问dom。")]),e._v(" "),r("li",[e._v("beforeMount：组件生命周期")]),e._v(" "),r("li",[e._v("deactivated：离开缓存组件a，或者触发a的beforeDestroy和destroyed组件销毁钩子。")]),e._v(" "),r("li",[e._v("mounted：访问/操作dom。")]),e._v(" "),r("li",[e._v("activated：进入缓存组件，进入a的嵌套子组件（如果有的话）。")]),e._v(" "),r("li",[e._v("执行beforeRouteEnter回调函数next。")])]),e._v(" "),r("ol",[r("li",[e._v("导航行为被触发到导航完成的整个过程")])]),e._v(" "),r("ul",[r("li",[e._v("导航行为被触发，此时导航未被确认。")]),e._v(" "),r("li",[e._v("在失活的组件里调用离开守卫 beforeRouteLeave。")]),e._v(" "),r("li",[e._v("调用全局的 beforeEach守卫。")]),e._v(" "),r("li",[e._v("在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。")]),e._v(" "),r("li",[e._v("在路由配置里调用 beforeEnteY。")]),e._v(" "),r("li",[e._v("解析异步路由组件（如果有）。")]),e._v(" "),r("li",[e._v("在被激活的组件里调用 beforeRouteEnter。")]),e._v(" "),r("li",[e._v("调用全局的 beforeResolve 守卫（2.5+），标示解析阶段完成。")]),e._v(" "),r("li",[e._v("导航被确认。")]),e._v(" "),r("li",[e._v("调用全局的 afterEach 钩子。")]),e._v(" "),r("li",[e._v("非重用组件，开始组件实例的生命周期：beforeCreate&created、beforeMount&mounted")]),e._v(" "),r("li",[e._v("触发 DOM 更新。")]),e._v(" "),r("li",[e._v("用创建好的实例调用 beforeRouteEnter守卫中传给 next 的回调函数。")]),e._v(" "),r("li",[e._v("导航完成")])]),e._v(" "),r("h2",{attrs:{id:"_7-vue-router跳转和location-href有什么区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_7-vue-router跳转和location-href有什么区别"}},[e._v("#")]),e._v(" 7. Vue-router跳转和location.href有什么区别")]),e._v(" "),r("ul",[r("li",[e._v("使用 "),r("code",[e._v("location.href= /url")]),e._v("来跳转，简单方便，但是刷新了页面；")]),e._v(" "),r("li",[e._v("使用 "),r("code",[e._v("history.pushState( /url )")]),e._v(" ，无刷新页面，静态跳转；")]),e._v(" "),r("li",[e._v("引进 router ，然后使用 "),r("code",[e._v("router.push( /url )")]),e._v(" 来跳转，使用了 "),r("code",[e._v("diff")]),e._v(" 算法，实现了按需加载，减少了 dom 的消耗。其实使用 router 跳转和使用 "),r("code",[e._v("history.pushState()")]),e._v(" 没什么差别的，因为vue-router就是用了 "),r("code",[e._v("history.pushState()")]),e._v(" ，尤其是在history模式下。")])]),e._v(" "),r("h2",{attrs:{id:"_8-params和query的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8-params和query的区别"}},[e._v("#")]),e._v(" 8. params和query的区别")]),e._v(" "),r("p",[r("strong",[e._v("用法")]),e._v("：query要用path来引入，params要用name来引入，接收参数都是类似的，分别是 "),r("code",[e._v("this.$route.query.name")]),e._v(" 和 "),r("code",[e._v("this.$route.params.name")]),e._v(" 。")]),e._v(" "),r("p",[r("strong",[e._v("url地址显示")]),e._v("：query更加类似于ajax中get传参，params则类似于post，说的再简单一点，前者在浏览器地址栏中显示参数，后者则不显示")]),e._v(" "),r("p",[r("strong",[e._v("注意")]),e._v("：query刷新不会丢失query里面的数据 params刷新会丢失 params里面的数据。")]),e._v(" "),r("h2",{attrs:{id:"_9-vue-router-导航守卫有哪些"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9-vue-router-导航守卫有哪些"}},[e._v("#")]),e._v(" 9. Vue-router 导航守卫有哪些")]),e._v(" "),r("ul",[r("li",[e._v("全局前置/钩子：beforeEach、beforeResolve、afterEach")]),e._v(" "),r("li",[e._v("路由独享的守卫：beforeEnter")]),e._v(" "),r("li",[e._v("组件内的守卫：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave")])]),e._v(" "),r("h2",{attrs:{id:"_10-对前端路由的理解"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_10-对前端路由的理解"}},[e._v("#")]),e._v(" 10. 对前端路由的理解")]),e._v(" "),r("p",[e._v("在前端技术早期，一个 url 对应一个页面，如果要从 A 页面切换到 B 页面，那么必然伴随着页面的刷新。这个体验并不好，不过在最初也是无奈之举——用户只有在刷新页面的情况下，才可以重新去请求数据。")]),e._v(" "),r("p",[e._v("后来，改变发生了——Ajax 出现了，它允许人们在不刷新页面的情况下发起请求；与之共生的，还有“不刷新页面即可更新页面内容”这种需求。在这样的背景下，出现了 "),r("strong",[e._v("SPA（单页面应用")]),e._v("）。")]),e._v(" "),r("p",[e._v("SPA极大地提升了用户体验，它允许页面在不刷新的情况下更新页面内容，使内容的切换更加流畅。但是在 SPA 诞生之初，人们并没有考虑到“定位”这个问题——在内容切换前后，页面的 URL 都是一样的，这就带来了两个问题：")]),e._v(" "),r("ul",[r("li",[e._v("SPA 其实并不知道当前的页面“进展到了哪一步”。可能在一个站点下经过了反复的“前进”才终于唤出了某一块内容，但是此时只要刷新一下页面，一切就会被清零，必须重复之前的操作、才可以重新对内容进行定位——SPA 并不会“记住”你的操作。")]),e._v(" "),r("li",[e._v("由于有且仅有一个 URL 给页面做映射，这对 SEO 也不够友好，搜索引擎无法收集全面的信息")])]),e._v(" "),r("p",[e._v("为了解决这个问题，前端路由出现了。")]),e._v(" "),r("p",[e._v("前端路由可以帮助我们在仅有一个页面的情况下，“记住”用户当前走到了哪一步——为 SPA 中的各个视图匹配一个唯一标识。这意味着用户前进、后退触发的新内容，都会映射到不同的 URL 上去。此时即便他刷新页面，因为当前的 URL 可以标识出他所处的位置，因此内容也不会丢失。")]),e._v(" "),r("p",[e._v("那么如何实现这个目的呢？首先要解决两个问题：")]),e._v(" "),r("ul",[r("li",[e._v("当用户刷新页面时，浏览器会默认根据当前 URL 对资源进行重新定位（发送请求）。这个动作对 SPA 是不必要的，因为我们的 SPA 作为单页面，无论如何也只会有一个资源与之对应。此时若走正常的请求-刷新流程，反而会使用户的前进后退操作无法被记录。")]),e._v(" "),r("li",[e._v("单页面应用对服务端来说，就是一个URL、一套资源，那么如何做到用“不同的URL”来映射不同的视图内容呢？")])]),e._v(" "),r("p",[e._v("从这两个问题来看，服务端已经完全救不了这个场景了。所以要靠咱们前端自力更生，不然怎么叫“前端路由”呢？作为前端，可以提供这样的解决思路：")]),e._v(" "),r("ul",[r("li",[e._v("拦截用户的刷新操作，避免服务端盲目响应、返回不符合预期的资源内容。把刷新这个动作完全放到前端逻辑里消化掉。")]),e._v(" "),r("li",[e._v("感知 URL 的变化。这里不是说要改造 URL、凭空制造出 N 个 URL 来。而是说 URL 还是那个 URL，只不过我们可以给它做一些微小的处理——这些处理并不会影响 URL 本身的性质，不会影响服务器对它的识别，只有我们前端感知的到。一旦我们感知到了，我们就根据这些变化、用 JS 去给它生成不同的内容。")])])])}),[],!1,null,null,null);t.default=v.exports}}]);