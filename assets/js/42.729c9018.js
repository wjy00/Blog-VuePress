(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{526:function(v,_,e){"use strict";e.r(_);var t=e(54),a=Object(t.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"七、虚拟dom"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#七、虚拟dom"}},[v._v("#")]),v._v(" 七、虚拟DOM")]),v._v(" "),e("h2",{attrs:{id:"_1-对虚拟dom的理解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-对虚拟dom的理解"}},[v._v("#")]),v._v(" 1. 对虚拟DOM的理解？")]),v._v(" "),e("p",[v._v("从本质上来说，Virtual Dom是一个JavaScript对象，通过对象的方式来表示DOM结构。将页面的状态抽象为JS对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。通过事务处理机制，将多次DOM修改的结果一次性的更新到页面上，从而有效的减少页面渲染的次数，减少修改DOM的重绘重排次数，提高渲染性能。")]),v._v(" "),e("p",[v._v("虚拟DOM是对DOM的抽象，这个对象是更加轻量级的对 DOM的描述。它设计的最初目的，就是更好的跨平台，比如Node.js就没有DOM，如果想实现SSR，那么一个方式就是借助虚拟DOM，因为虚拟DOM本身是js对象。 在代码渲染到页面之前，vue会把代码转换成一个对象（虚拟 DOM）。以对象的形式来描述真实DOM结构，最终渲染到页面。在每次数据发生变化前，虚拟DOM都会缓存一份，变化之时，现在的虚拟DOM会与缓存的虚拟DOM进行比较。在vue内部封装了diff算法，通过这个算法来进行比较，渲染时修改改变的变化，原先没有发生改变的通过原先的数据进行渲染。")]),v._v(" "),e("p",[v._v("另外现代前端框架的一个基本要求就是无须手动操作DOM，一方面是因为手动操作DOM无法保证程序性能，多人协作的项目中如果review不严格，可能会有开发者写出性能较低的代码，另一方面更重要的是省略手动DOM操作可以大大提高开发效率。")]),v._v(" "),e("h2",{attrs:{id:"_2-虚拟dom的解析过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-虚拟dom的解析过程"}},[v._v("#")]),v._v(" 2. 虚拟DOM的解析过程")]),v._v(" "),e("p",[v._v("虚拟DOM的解析过程：")]),v._v(" "),e("ul",[e("li",[v._v("首先对将要插入到文档中的 DOM 树结构进行分析，使用 js 对象将其表示出来，比如一个元素对象，包含 TagName、props 和 Children 这些属性。然后将这个 js 对象树给保存下来，最后再将 DOM 片段插入到文档中。")]),v._v(" "),e("li",[v._v("当页面的状态发生改变，需要对页面的 DOM 的结构进行调整的时候，首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的的差异。")]),v._v(" "),e("li",[v._v("最后将记录的有差异的地方应用到真正的 DOM 树中去，这样视图就更新了。")])]),v._v(" "),e("h2",{attrs:{id:"_3-为什么要用虚拟dom"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-为什么要用虚拟dom"}},[v._v("#")]),v._v(" 3. 为什么要用虚拟DOM")]),v._v(" "),e("p",[e("strong",[v._v("（1）保证性能下限，在不进行手动优化的情况下，提供过得去的性能")])]),v._v(" "),e("p",[v._v("看一下页面渲染的流程："),e("strong",[v._v("解析HTML -> 生成DOM")]),v._v(" "),e("strong",[v._v("->")]),v._v(" "),e("strong",[v._v("生成 CSSOM")]),v._v(" "),e("strong",[v._v("->")]),v._v(" "),e("strong",[v._v("Layout")]),v._v(" "),e("strong",[v._v("->")]),v._v(" "),e("strong",[v._v("Paint")]),v._v(" "),e("strong",[v._v("->")]),v._v(" "),e("strong",[v._v("Compiler")])]),v._v(" "),e("p",[v._v("下面对比一下修改DOM时真实DOM操作和Virtual DOM的过程，来看一下它们重排重绘的性能消耗∶")]),v._v(" "),e("ul",[e("li",[v._v("真实DOM∶ 生成HTML字符串＋重建所有的DOM元素")]),v._v(" "),e("li",[v._v("虚拟DOM∶ 生成vNode+ DOMDiff＋必要的dom更新")])]),v._v(" "),e("p",[v._v("Virtual DOM的更新DOM的准备工作耗费更多的时间，也就是JS层面，相比于更多的DOM操作它的消费是极其便宜的。尤雨溪在社区论坛中说道∶ 框架给你的保证是，你不需要手动优化的情况下，依然可以给你提供过得去的性能。")]),v._v(" "),e("p",[e("strong",[v._v("（2）跨平台")])]),v._v(" "),e("p",[v._v("Virtual DOM本质上是JavaScript的对象，它可以很方便的跨平台操作，比如服务端渲染、uniapp等。")]),v._v(" "),e("h2",{attrs:{id:"_4-虚拟dom真的比真实dom性能好吗"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-虚拟dom真的比真实dom性能好吗"}},[v._v("#")]),v._v(" 4. 虚拟DOM真的比真实DOM性能好吗")]),v._v(" "),e("ul",[e("li",[v._v("首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢。")]),v._v(" "),e("li",[v._v("正如它能保证性能下限，在真实DOM操作的时候进行针对性的优化时，还是更快的。")])]),v._v(" "),e("h2",{attrs:{id:"_5-diff算法的原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-diff算法的原理"}},[v._v("#")]),v._v(" 5. DIFF算法的原理")]),v._v(" "),e("p",[v._v("在新老虚拟DOM对比时：")]),v._v(" "),e("ul",[e("li",[v._v("首先，对比节点本身，判断是否为同一节点，如果不为相同节点，则删除该节点重新创建节点进行替换")]),v._v(" "),e("li",[v._v("如果为相同节点，进行patchVnode，判断如何对该节点的子节点进行处理，先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)")]),v._v(" "),e("li",[v._v("比较如果都有子节点，则进行updateChildren，判断如何对这些新老节点的子节点进行操作（diff核心）。")]),v._v(" "),e("li",[v._v("匹配时，找到相同的子节点，递归比较子节点")])]),v._v(" "),e("p",[v._v("在diff中，只对同层的子节点进行比较，放弃跨级的节点比较，使得时间复杂从O(n3)降低值O(n)，也就是说，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。")]),v._v(" "),e("h2",{attrs:{id:"_6-vue中key的作用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-vue中key的作用"}},[v._v("#")]),v._v(" 6. Vue中key的作用")]),v._v(" "),e("p",[v._v("vue 中 key 值的作用可以分为两种情况来考虑：")]),v._v(" "),e("ul",[e("li",[v._v("第一种情况是 v-if 中使用 key。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。")]),v._v(" "),e("li",[v._v("第二种情况是 v-for 中使用 key。用 v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，来以便 Vue 跟踪元素的身份，从而高效的实现复用。这个时候 key 的作用是为了高效的更新渲染虚拟 DOM。")])]),v._v(" "),e("p",[v._v("key 是为 Vue 中 vnode 的唯一标记，通过这个 key，diff 操作可以更准确、更快速")]),v._v(" "),e("ul",[e("li",[v._v("更准确：因为带 key 就不是就地复用了，在 sameNode 函数"),e("code",[v._v("a.key === b.key")]),v._v("对比中可以避免就地复用的情况。所以会更加准确。")]),v._v(" "),e("li",[v._v("更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快")])]),v._v(" "),e("h2",{attrs:{id:"_7-为什么不建议用index作为key"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-为什么不建议用index作为key"}},[v._v("#")]),v._v(" 7. 为什么不建议用index作为key?")]),v._v(" "),e("p",[v._v("使用index 作为 key和没写基本上没区别，因为不管数组的顺序怎么颠倒，index 都是 0, 1, 2...这样排列，导致 Vue 会复用错误的旧子节点，做很多额外的工作。")])])}),[],!1,null,null,null);_.default=a.exports}}]);