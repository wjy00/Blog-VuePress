(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{554:function(t,e,s){"use strict";s.r(e);var n=s(54),a=Object(n.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"七、异步编程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#七、异步编程"}},[t._v("#")]),t._v(" 七、异步编程")]),t._v(" "),s("h2",{attrs:{id:"_1-异步编程的实现方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-异步编程的实现方式"}},[t._v("#")]),t._v(" 1. 异步编程的实现方式？")]),t._v(" "),s("p",[t._v("JavaScript 中的异步机制可以分为以下几种：")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("回调函数")]),t._v(" 的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。")]),t._v(" "),s("li",[s("strong",[t._v("Promise")]),t._v(" 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。")]),t._v(" "),s("li",[s("strong",[t._v("generator")]),t._v(" 的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部还可以将执行权转移回来。当遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕时再将执行权给转移回来。因此在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式需要考虑的问题是何时将函数的控制权转移回来，因此需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。")]),t._v(" "),s("li",[s("strong",[t._v("async 函数")]),t._v(" 的方式，async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。")])]),t._v(" "),s("h2",{attrs:{id:"_2-settimeout、promise、async-await-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-settimeout、promise、async-await-的区别"}},[t._v("#")]),t._v(" 2. setTimeout、Promise、Async/Await 的区别")]),t._v(" "),s("h3",{attrs:{id:"_1-settimeout"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-settimeout"}},[t._v("#")]),t._v(" （1）setTimeout")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[t._v("console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'script start'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//1. 打印 script start")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("setTimeout")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'settimeout'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 4. 打印 settimeout")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 2. 调用 setTimeout 函数，并定义其完成后执行的回调函数")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'script end'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//3. 打印 script start")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 输出顺序：script start->script end->settimeout")]),t._v("\n")])])]),s("h3",{attrs:{id:"_2-promise"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-promise"}},[t._v("#")]),t._v(" （2）Promise")]),t._v(" "),s("p",[t._v("Promise 本身是"),s("strong",[t._v("同步的立即执行函数")]),t._v("， 当在 executor 中执行 resolve 或者 reject 的时候, 此时是异步操作， 会先执行 then/catch 等，当主栈完成后，才会去调用 resolve/reject 中存放的方法执行，打印的时候，是打印的返回结果，一个 Promise 实例。")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[t._v("console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'script start'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" promise1 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Promise")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("resolve")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'promise1'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("resolve")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'promise1 end'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("then")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'promise2'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("setTimeout")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'settimeout'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'script end'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 输出顺序: script start->promise1->promise1 end->script end->promise2->settimeout")]),t._v("\n")])])]),s("p",[t._v("当 JS 主线程执行到 Promise 对象时：")]),t._v(" "),s("ul",[s("li",[t._v("promise1.then() 的回调就是一个 task")]),t._v(" "),s("li",[t._v("promise1 是 resolved 或 rejected: 那这个 task 就会放入当前事件循环回合的 microtask queue（微任务队列）")]),t._v(" "),s("li",[t._v("promise1 是 pending: 这个 task 就会放入 事件循环的未来的某个(可能下一个)回合的 microtask queue 中")]),t._v(" "),s("li",[t._v("setTimeout 的回调也是个 task ，它会被放入 macrotask queue（宏任务队列） 即使是 0ms 的情况")])]),t._v(" "),s("h3",{attrs:{id:"_3-async-await"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-async-await"}},[t._v("#")]),t._v(" （3）async/await")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("async")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("async1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'async1 start'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("await")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("async2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'async1 end'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("async")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("async2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'async2'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'script start'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("async1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'script end'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 输出顺序：script start->async1 start->async2->script end->async1 end")]),t._v("\n")])])]),s("p",[t._v("async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。")]),t._v(" "),s("p",[t._v("例如：")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("async")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("func1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("func1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[s("img",{attrs:{src:"F:%5C%E5%89%8D%E7%AB%AF%5C%E5%89%8D%E7%AB%AF%5CVuePress%5CBlog-VuePress%5Cdocs%5Cjavascript%5Cassets%5C6.png",alt:"img"}})]),t._v(" "),s("p",[t._v("func1 的运行结果其实就是一个 Promise 对象。因此也可以使用 then 来处理后续逻辑。")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("func1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("then")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("res")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("res"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 30")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("await 的含义为等待，也就是 async 函数需要等待 await 后的函数执行完成并且有了返回结果（Promise 对象）之后，才能继续执行下面的代码。await 通过返回一个 Promise 对象来实现同步的效果。")]),t._v(" "),s("h2",{attrs:{id:"_3-对-promise-的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-对-promise-的理解"}},[t._v("#")]),t._v(" 3. 对 Promise 的理解")]),t._v(" "),s("p",[t._v("Promise 是异步编程的一种解决方案，它是一个对象，可以获取异步操作的消息，他的出现大大改善了异步编程的困境，避免了地狱回调，它比传统的解决方案回调函数和事件更合理和更强大。")]),t._v(" "),s("p",[t._v("所谓 Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。")]),t._v(" "),s("p",[t._v("（1）Promise 的实例有"),s("strong",[t._v("三个状态")]),t._v(":")]),t._v(" "),s("ul",[s("li",[t._v("Pending（进行中）")]),t._v(" "),s("li",[t._v("Resolved（已完成）")]),t._v(" "),s("li",[t._v("Rejected（已拒绝）")])]),t._v(" "),s("p",[t._v("当把一件事情交给 promise 时，它的状态就是 Pending，任务完成了状态就变成了 Resolved、没有完成失败了就变成了 Rejected。")]),t._v(" "),s("p",[t._v("（2）Promise 的实例有"),s("strong",[t._v("两个过程")]),t._v("：")]),t._v(" "),s("ul",[s("li",[t._v("pending -> fulfilled : Resolved（已完成）")]),t._v(" "),s("li",[t._v("pending -> rejected：Rejected（已拒绝）")])]),t._v(" "),s("p",[t._v("注意：一旦从进行状态变成为其他状态就永远不能更改状态了。")]),t._v(" "),s("p",[s("strong",[t._v("Promise 的特点：")])]),t._v(" "),s("ul",[s("li",[t._v("对象的状态不受外界影响。promise 对象代表一个异步操作，有三种状态，"),s("code",[t._v("pending")]),t._v("（进行中）、"),s("code",[t._v("fulfilled")]),t._v("（已成功）、"),s("code",[t._v("rejected")]),t._v("（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也是 promise 这个名字的由来——“"),s("strong",[t._v("承诺")]),t._v("”；")]),t._v(" "),s("li",[t._v("一旦状态改变就不会再变，任何时候都可以得到这个结果。promise 对象的状态改变，只有两种可能：从"),s("code",[t._v("pending")]),t._v("变为"),s("code",[t._v("fulfilled")]),t._v("，从"),s("code",[t._v("pending")]),t._v("变为"),s("code",[t._v("rejected")]),t._v("。这时就称为"),s("code",[t._v("resolved")]),t._v("（已定型）。如果改变已经发生了，你再对 promise 对象添加回调函数，也会立即得到这个结果。这与事件（event）完全不同，事件的特点是：如果你错过了它，再去监听是得不到结果的。")])]),t._v(" "),s("p",[s("strong",[t._v("Promise 的缺点：")])]),t._v(" "),s("ul",[s("li",[t._v("无法取消 Promise，一旦新建它就会立即执行，无法中途取消。")]),t._v(" "),s("li",[t._v("如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。")]),t._v(" "),s("li",[t._v("当处于 pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。")])]),t._v(" "),s("p",[s("strong",[t._v("总结：")])]),t._v(" "),s("p",[t._v("Promise 对象是异步编程的一种解决方案，最早由社区提出。Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。一个 Promise 实例有三种状态，分别是 pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者 rejected 状态，并且状态一经改变，就凝固了，无法再被改变了。")]),t._v(" "),s("p",[t._v("状态的改变是通过 resolve() 和 reject() 函数来实现的，可以在异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。")]),t._v(" "),s("p",[t._v("**注意：**在构造 "),s("code",[t._v("Promise")]),t._v(" 的时候，构造函数内部的代码是立即执行的")]),t._v(" "),s("h2",{attrs:{id:"_4-promise-的基本用法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-promise-的基本用法"}},[t._v("#")]),t._v(" 4. Promise 的基本用法")]),t._v(" "),s("h3",{attrs:{id:"_1-创建-promise-对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-创建-promise-对象"}},[t._v("#")]),t._v(" （1）创建 Promise 对象")]),t._v(" "),s("p",[t._v("Promise 对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。")]),t._v(" "),s("p",[t._v("Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是"),s("code",[t._v("resolve")]),t._v("和"),s("code",[t._v("reject")]),t._v("。")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" promise "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Promise")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("resolve"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" reject")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ... some code")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 异步操作成功 */")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("resolve")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("reject")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("error"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[s("strong",[t._v("一般情况下都会使用")]),s("code",[t._v("**new Promise()**")]),s("strong",[t._v("来创建 promise 对象，但是也可以使用")]),s("code",[t._v("**promise.resolve**")]),s("strong",[t._v("和")]),t._v(" "),s("code",[t._v("**promise.reject**")]),s("strong",[t._v("这两个方法：")])]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("Promise.resolve")])])]),t._v(" "),s("p",[s("code",[t._v("Promise.resolve(value)")]),t._v("的返回值也是一个 promise 对象，可以对返回值进行.then 调用，代码如下：")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("Promise"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("resolve")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("11")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("then")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("value")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 打印出11")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[s("code",[t._v("resolve(11)")]),t._v("代码中，会让 promise 对象进入确定("),s("code",[t._v("resolve")]),t._v("状态)，并将参数"),s("code",[t._v("11")]),t._v("传递给后面的"),s("code",[t._v("then")]),t._v("所指定的"),s("code",[t._v("onFulfilled")]),t._v(" 函数；")]),t._v(" "),s("p",[t._v("创建 promise 对象可以使用"),s("code",[t._v("new Promise")]),t._v("的形式创建对象，也可以使用"),s("code",[t._v("Promise.resolve(value)")]),t._v("的形式创建 promise 对象；")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("Promise.reject")])])]),t._v(" "),s("p",[s("code",[t._v("Promise.reject")]),t._v(" 也是"),s("code",[t._v("new Promise")]),t._v("的快捷形式，也创建一个 promise 对象。代码如下：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("Promise.reject(new Error(“我错了，请原谅俺！！”));\n")])])]),s("p",[t._v("就是下面的代码 new Promise 的简单形式：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('new Promise(function(resolve,reject){\n   reject(new Error("我错了，请原谅俺！！"));\n});\n')])])]),s("p",[t._v("下面是使用 resolve 方法和 reject 方法：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('function testPromise(ready) {\n  return new Promise(function(resolve,reject){\n    if(ready) {\n      resolve("hello world");\n    }else {\n      reject("No thanks");\n    }\n  });\n};\n// 方法调用\ntestPromise(true).then(function(msg){\n  console.log(msg);\n},function(error){\n  console.log(error);\n});\n')])])]),s("p",[t._v("上面的代码的含义是给"),s("code",[t._v("testPromise")]),t._v("方法传递一个参数，返回一个 promise 对象，如果为"),s("code",[t._v("true")]),t._v("的话，那么调用 promise 对象中的"),s("code",[t._v("resolve()")]),t._v("方法，并且把其中的参数传递给后面的"),s("code",[t._v("then")]),t._v("第一个函数内，因此打印出 “"),s("code",[t._v("hello world")]),t._v("”, 如果为"),s("code",[t._v("false")]),t._v("的话，会调用 promise 对象中的"),s("code",[t._v("reject()")]),t._v("方法，则会进入"),s("code",[t._v("then")]),t._v("的第二个函数内，会打印"),s("code",[t._v("No thanks")]),t._v("；")]),t._v(" "),s("h3",{attrs:{id:"_2-promise-方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-promise-方法"}},[t._v("#")]),t._v(" （2）Promise 方法")]),t._v(" "),s("p",[t._v("Promise 有五个常用的方法：then()、catch()、all()、race()、finally。下面就来看一下这些方法。")]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("then()")])])]),t._v(" "),s("p",[t._v("当 Promise 执行的内容符合成功条件时，调用"),s("code",[t._v("resolve")]),t._v("函数，失败就调用"),s("code",[t._v("reject")]),t._v("函数。Promise 创建完了，那该如何调用呢？")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("promise.then(function(value) {\n  // success\n}, function(error) {\n  // failure\n});\n")])])]),s("p",[s("code",[t._v("then")]),t._v("方法可以接受两个回调函数作为参数。第一个回调函数是 Promise 对象的状态变为"),s("code",[t._v("resolved")]),t._v("时调用，第二个回调函数是 Promise 对象的状态变为"),s("code",[t._v("rejected")]),t._v("时调用。其中第二个参数可以省略。")]),t._v(" "),s("p",[s("code",[t._v("then")]),t._v("方法返回的是一个新的 Promise 实例（不是原来那个 Promise 实例）。因此可以采用链式写法，即"),s("code",[t._v("then")]),t._v("方法后面再调用另一个 then 方法。")]),t._v(" "),s("p",[t._v("当要写有顺序的异步事件时，需要串行时，可以这样写：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("let promise = new Promise((resolve,reject)=>{\n    ajax('first').success(function(res){\n        resolve(res);\n    })\n})\npromise.then(res=>{\n    return new Promise((resovle,reject)=>{\n        ajax('second').success(function(res){\n            resolve(res)\n        })\n    })\n}).then(res=>{\n    return new Promise((resovle,reject)=>{\n        ajax('second').success(function(res){\n            resolve(res)\n        })\n    })\n}).then(res=>{\n\n})\n")])])]),s("p",[t._v("那当要写的事件没有顺序或者关系时，还如何写呢？可以使用"),s("code",[t._v("all")]),t._v(" 方法来解决。")]),t._v(" "),s("p",[s("strong",[t._v("2. catch()")])]),t._v(" "),s("p",[t._v("Promise 对象除了有 then 方法，还有一个 catch 方法，该方法相当于"),s("code",[t._v("then")]),t._v("方法的第二个参数，指向"),s("code",[t._v("reject")]),t._v("的回调函数。不过"),s("code",[t._v("catch")]),t._v("方法还有一个作用，就是在执行"),s("code",[t._v("resolve")]),t._v("回调函数时，如果出现错误，抛出异常，不会停止运行，而是进入"),s("code",[t._v("catch")]),t._v("方法中。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("p.then((data) => {\n     console.log('resolved',data);\n},(err) => {\n     console.log('rejected',err);\n     }\n);\np.then((data) => {\n    console.log('resolved',data);\n}).catch((err) => {\n    console.log('rejected',err);\n});\n")])])]),s("p",[s("strong",[t._v("3. all()")])]),t._v(" "),s("p",[s("code",[t._v("all")]),t._v("方法可以完成并行任务， 它接收一个数组，数组的每一项都是一个"),s("code",[t._v("promise")]),t._v("对象。当数组中所有的"),s("code",[t._v("promise")]),t._v("的状态都达到"),s("code",[t._v("resolved")]),t._v("的时候，"),s("code",[t._v("all")]),t._v("方法的状态就会变成"),s("code",[t._v("resolved")]),t._v("，如果有一个状态变成了"),s("code",[t._v("rejected")]),t._v("，那么"),s("code",[t._v("all")]),t._v("方法的状态就会变成"),s("code",[t._v("rejected")]),t._v("。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("javascript\nlet promise1 = new Promise((resolve,reject)=>{\n    setTimeout(()=>{\n       resolve(1);\n    },2000)\n});\nlet promise2 = new Promise((resolve,reject)=>{\n    setTimeout(()=>{\n       resolve(2);\n    },1000)\n});\nlet promise3 = new Promise((resolve,reject)=>{\n    setTimeout(()=>{\n       resolve(3);\n    },3000)\n});\nPromise.all([promise1,promise2,promise3]).then(res=>{\n    console.log(res);\n    //结果为：[1,2,3]\n})\n")])])]),s("p",[t._v("调用"),s("code",[t._v("all")]),t._v("方法时的结果成功的时候是回调函数的参数也是一个数组，这个数组按顺序保存着每一个 promise 对象"),s("code",[t._v("resolve")]),t._v("执行时的值。")]),t._v(" "),s("p",[s("strong",[t._v("（4）race()")])]),t._v(" "),s("p",[s("code",[t._v("race")]),t._v("方法和"),s("code",[t._v("all")]),t._v("一样，接受的参数是一个每项都是"),s("code",[t._v("promise")]),t._v("的数组，但是与"),s("code",[t._v("all")]),t._v("不同的是，当最先执行完的事件执行完之后，就直接返回该"),s("code",[t._v("promise")]),t._v("对象的值。如果第一个"),s("code",[t._v("promise")]),t._v("对象状态变成"),s("code",[t._v("resolved")]),t._v("，那自身的状态变成了"),s("code",[t._v("resolved")]),t._v("；反之第一个"),s("code",[t._v("promise")]),t._v("变成"),s("code",[t._v("rejected")]),t._v("，那自身状态就会变成"),s("code",[t._v("rejected")]),t._v("。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("let promise1 = new Promise((resolve,reject)=>{\n    setTimeout(()=>{\n       reject(1);\n    },2000)\n});\nlet promise2 = new Promise((resolve,reject)=>{\n    setTimeout(()=>{\n       resolve(2);\n    },1000)\n});\nlet promise3 = new Promise((resolve,reject)=>{\n    setTimeout(()=>{\n       resolve(3);\n    },3000)\n});\nPromise.race([promise1,promise2,promise3]).then(res=>{\n    console.log(res);\n    //结果：2\n},rej=>{\n    console.log(rej)};\n)\n")])])]),s("p",[t._v("那么"),s("code",[t._v("race")]),t._v("方法有什么实际作用呢？当要做一件事，超过多长时间就不做了，可以用这个方法来解决：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("Promise.race([promise1,timeOutPromise(5000)]).then(res=>{})\n")])])]),s("p",[s("strong",[t._v("5. finally()")])]),t._v(" "),s("p",[s("code",[t._v("finally")]),t._v("方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("promise\n.then(result => {···})\n.catch(error => {···})\n.finally(() => {···});\n")])])]),s("p",[t._v("上面代码中，不管"),s("code",[t._v("promise")]),t._v("最后的状态，在执行完"),s("code",[t._v("then")]),t._v("或"),s("code",[t._v("catch")]),t._v("指定的回调函数以后，都会执行"),s("code",[t._v("finally")]),t._v("方法指定的回调函数。")]),t._v(" "),s("p",[t._v("下面是一个例子，服务器使用 Promise 处理请求，然后使用"),s("code",[t._v("finally")]),t._v("方法关掉服务器。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("server.listen(port)\n  .then(function () {\n    // ...\n  })\n  .finally(server.stop);\n")])])]),s("p",[s("code",[t._v("finally")]),t._v("方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是"),s("code",[t._v("fulfilled")]),t._v("还是"),s("code",[t._v("rejected")]),t._v("。这表明，"),s("code",[t._v("finally")]),t._v("方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。"),s("code",[t._v("finally")]),t._v("本质上是"),s("code",[t._v("then")]),t._v("方法的特例：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("promise\n.finally(() => {\n  // 语句\n});\n// 等同于\npromise\n.then(\n  result => {\n    // 语句\n    return result;\n  },\n  error => {\n    // 语句\n    throw error;\n  }\n);\n")])])]),s("p",[t._v("上面代码中，如果不使用"),s("code",[t._v("finally")]),t._v("方法，同样的语句需要为成功和失败两种情况各写一次。有了"),s("code",[t._v("finally")]),t._v("方法，则只需要写一次。")]),t._v(" "),s("h2",{attrs:{id:"_5-promise-解决了什么问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-promise-解决了什么问题"}},[t._v("#")]),t._v(" 5. Promise 解决了什么问题")]),t._v(" "),s("p",[t._v("在工作中经常会碰到这样一个需求，比如我使用 ajax 发一个 A 请求后，成功后拿到数据，需要把数据传给 B 请求；那么需要如下编写代码：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("let fs = require('fs')\nfs.readFile('./a.txt','utf8',function(err,data){\n  fs.readFile(data,'utf8',function(err,data){\n    fs.readFile(data,'utf8',function(err,data){\n      console.log(data)\n    })\n  })\n})\n")])])]),s("p",[t._v("上面的代码有如下缺点：")]),t._v(" "),s("ul",[s("li",[t._v("后一个请求需要依赖于前一个请求成功后，将数据往下传递，会导致多个 ajax 请求嵌套的情况，代码不够直观。")]),t._v(" "),s("li",[t._v("如果前后两个请求不需要传递参数的情况下，那么后一个请求也需要前一个请求成功后再执行下一步操作，这种情况下，那么也需要如上编写代码，导致代码不够直观。")])]),t._v(" "),s("p",[s("code",[t._v("Promise")]),t._v("出现之后，代码变成这样：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("let fs = require('fs')\nfunction read(url){\n  return new Promise((resolve,reject)=>{\n    fs.readFile(url,'utf8',function(error,data){\n      error && reject(error)\n      resolve(data)\n    })\n  })\n}\nread('./a.txt').then(data=>{\n  return read(data)\n}).then(data=>{\n  return read(data)\n}).then(data=>{\n  console.log(data)\n})\n")])])]),s("p",[t._v("这样代码看起了就简洁了很多，解决了地狱回调的问题。")]),t._v(" "),s("h2",{attrs:{id:"_6-promise-all-和-promise-race-的区别的使用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-promise-all-和-promise-race-的区别的使用场景"}},[t._v("#")]),t._v(" 6. Promise.all 和 Promise.race 的区别的使用场景")]),t._v(" "),s("p",[t._v("**（1）****Promise.all**")]),t._v(" "),s("p",[s("code",[t._v("Promise.all")]),t._v("可以将多个"),s("code",[t._v("Promise")]),t._v("实例包装成一个新的 Promise 实例。同时，成功和失败的返回值是不同的，成功的时候返回的是"),s("strong",[t._v("一个结果数组")]),t._v("，而失败的时候则返回"),s("strong",[t._v("最先被 reject 失败状态的值")]),t._v("。")]),t._v(" "),s("p",[t._v("Promise.all 中传入的是数组，返回的也是是数组，并且会将进行映射，传入的 promise 对象返回的值是按照顺序在数组中排列的，但是注意的是他们执行的顺序并不是按照顺序的，除非可迭代对象为空。")]),t._v(" "),s("p",[t._v("需要注意，Promise.all 获得的成功结果的数组里面的数据顺序和 Promise.all 接收到的数组顺序是一致的，这样当遇到发送多个请求并根据请求顺序获取和使用数据的场景，就可以使用 Promise.all 来解决。")]),t._v(" "),s("p",[s("strong",[t._v("（2）Promise.race")])]),t._v(" "),s("p",[t._v("顾名思义，Promse.race 就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。当要做一件事，超过多长时间就不做了，可以用这个方法来解决：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("Promise.race([promise1,timeOutPromise(5000)]).then(res=>{})\n")])])]),s("h2",{attrs:{id:"_7-对-async-await-的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-对-async-await-的理解"}},[t._v("#")]),t._v(" 7. 对 async/await 的理解")]),t._v(" "),s("p",[t._v("async/await 其实是"),s("code",[t._v("Generator")]),t._v(" 的语法糖，它能实现的效果都能用 then 链来实现，它是为优化 then 链而开发出来的。从字面上来看，async 是“异步”的简写，await 则为等待，所以很好理解 async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。当然语法上强制规定 await 只能出现在 asnyc 函数中，先来看看 async 函数返回了什么：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("async function testAsy(){\n   return 'hello world';\n}\nlet result = testAsy();\nconsole.log(result)\n")])])]),s("p",[s("img",{attrs:{src:"F:%5C%E5%89%8D%E7%AB%AF%5C%E5%89%8D%E7%AB%AF%5CVuePress%5CBlog-VuePress%5Cdocs%5Cjavascript%5Cassets%5C9.png",alt:"img"}})]),t._v(" "),s("p",[t._v("所以，async 函数返回的是一个 Promise 对象。async 函数（包含函数语句、函数表达式、Lambda 表达式）会返回一个 Promise 对象，如果在函数中 "),s("code",[t._v("return")]),t._v(" 一个直接量，async 会把这个直接量通过 "),s("code",[t._v("Promise.resolve()")]),t._v(" 封装成 Promise 对象。")]),t._v(" "),s("p",[t._v("async 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，当然应该用原来的方式："),s("code",[t._v("then()")]),t._v(" 链来处理这个 Promise 对象，就像这样：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("async function testAsy(){\n   return 'hello world'\n}\nlet result = testAsy()\nconsole.log(result)\nresult.then(v=>{\n    console.log(v)   // hello world\n})\n")])])]),s("p",[t._v("那如果 async 函数没有返回值，又该如何？很容易想到，它会返回 "),s("code",[t._v("Promise.resolve(undefined)")]),t._v("。")]),t._v(" "),s("p",[t._v("联想一下 Promise 的特点——无等待，所以在没有 "),s("code",[t._v("await")]),t._v(" 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。")]),t._v(" "),s("p",[s("strong",[t._v("注意：")]),s("code",[t._v("Promise.resolve(x)")]),t._v(" 可以看作是 "),s("code",[t._v("new Promise(resolve => resolve(x))")]),t._v(" 的简写，可以用于快速封装字面量对象或其他对象，将其封装成 Promise 实例。")]),t._v(" "),s("h2",{attrs:{id:"_8-await-到底在等啥"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-await-到底在等啥"}},[t._v("#")]),t._v(" 8. await 到底在等啥？")]),t._v(" "),s("p",[t._v("**await 在等待什么呢？**一般来说，都认为 await 是在等待一个 async 函数完成。不过按语法说明，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。")]),t._v(" "),s("p",[t._v("因为 async 函数返回一个 Promise 对象，所以 await 可以用于等待一个 async 函数的返回值——这也可以说是 await 在等 async 函数，但要清楚，它等的实际是一个返回值。注意到 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。所以下面这个示例完全可以正确运行：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('function getSomething() {\n    return "something";\n}\nasync function testAsync() {\n    return Promise.resolve("hello async");\n}\nasync function test() {\n    const v1 = await getSomething();\n    const v2 = await testAsync();\n    console.log(v1, v2);\n}\ntest();\n')])])]),s("p",[t._v("await 表达式的运算结果取决于它等的是什么。")]),t._v(" "),s("ul",[s("li",[t._v("如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。")]),t._v(" "),s("li",[t._v("如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。")])]),t._v(" "),s("p",[t._v("来看一个例子：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("function testAsy(x){\n   return new Promise(resolve=>{setTimeout(() => {\n       resolve(x);\n     }, 3000)\n    }\n   )\n}\nasync function testAwt(){\n  let result =  await testAsy('hello world');\n  console.log(result);    // 3秒钟之后出现hello world\n  console.log('cuger')   // 3秒钟之后出现cug\n}\ntestAwt();\nconsole.log('cug')  //立即输出cug\n")])])]),s("p",[t._v("这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。await 暂停当前 async 的执行，所以'cug''最先输出，hello world'和‘cuger’是 3 秒钟后同时出现的。")]),t._v(" "),s("h2",{attrs:{id:"_9-async-await-的优势"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-async-await-的优势"}},[t._v("#")]),t._v(" 9. async/await 的优势")]),t._v(" "),s("p",[t._v("单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async/await 来进一步优化它）。")]),t._v(" "),s("p",[t._v("假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。仍然用 "),s("code",[t._v("setTimeout")]),t._v(" 来模拟异步操作：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("/**\n * 传入参数 n，表示这个函数执行的时间（毫秒）\n * 执行的结果是 n + 200，这个值将用于下一步骤\n */\nfunction takeLongTime(n) {\n    return new Promise(resolve => {\n        setTimeout(() => resolve(n + 200), n);\n    });\n}\nfunction step1(n) {\n    console.log(`step1 with ${n}`);\n    return takeLongTime(n);\n}\nfunction step2(n) {\n    console.log(`step2 with ${n}`);\n    return takeLongTime(n);\n}\nfunction step3(n) {\n    console.log(`step3 with ${n}`);\n    return takeLongTime(n);\n}\n")])])]),s("p",[t._v("现在用 Promise 方式来实现这三个步骤的处理：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('function doIt() {\n    console.time("doIt");\n    const time1 = 300;\n    step1(time1)\n        .then(time2 => step2(time2))\n        .then(time3 => step3(time3))\n        .then(result => {\n            console.log(`result is ${result}`);\n            console.timeEnd("doIt");\n        });\n}\ndoIt();\n// c:\\var\\test>node --harmony_async_await .\n// step1 with 300\n// step2 with 500\n// step3 with 700\n// result is 900\n// doIt: 1507.251ms\n')])])]),s("p",[t._v("如果用 async/await 来实现呢，会是这样：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('async function doIt() {\n    console.time("doIt");\n    const time1 = 300;\n    const time2 = await step1(time1);\n    const time3 = await step2(time2);\n    const result = await step3(time3);\n    console.log(`result is ${result}`);\n    console.timeEnd("doIt");\n}\ndoIt();\n')])])]),s("p",[t._v("结果和之前的 Promise 实现是一样的，但是这个代码看起来是不是清晰得多，几乎跟同步代码一样")]),t._v(" "),s("h2",{attrs:{id:"_10-async-await-对比-promise-的优势"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_10-async-await-对比-promise-的优势"}},[t._v("#")]),t._v(" 10. async/await 对比 Promise 的优势")]),t._v(" "),s("ul",[s("li",[t._v("代码读起来更加同步，Promise 虽然摆脱了回调地狱，但是 then 的链式调⽤也会带来额外的阅读负担")]),t._v(" "),s("li",[t._v("Promise 传递中间值⾮常麻烦，⽽ async/await ⼏乎是同步的写法，⾮常优雅")]),t._v(" "),s("li",[t._v("错误处理友好，async/await 可以⽤成熟的 try/catch，Promise 的错误捕获⾮常冗余")]),t._v(" "),s("li",[t._v("调试友好，Promise 的调试很差，由于没有代码块，你不能在⼀个返回表达式的箭头函数中设置断点，如果你在⼀个.then 代码块中使⽤调试器的步进(step-over)功能，调试器并不会进⼊后续的.then 代码块，因为调试器只能跟踪同步代码的每⼀步。")])]),t._v(" "),s("h2",{attrs:{id:"_11-async-await-如何捕获异常"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_11-async-await-如何捕获异常"}},[t._v("#")]),t._v(" 11. async/await 如何捕获异常")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("async function fn(){\n    try{\n        let a = await Promise.reject('error')\n    }catch(error){\n        console.log(error)\n    }\n}\n")])])]),s("h2",{attrs:{id:"_12-并发与并行的区别-了解即可"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_12-并发与并行的区别-了解即可"}},[t._v("#")]),t._v(" 12. 并发与并行的区别？---了解即可")]),t._v(" "),s("ul",[s("li",[t._v("并发是宏观概念，我分别有任务 A 和任务 B，在一段时间内通过任务间的切换完成了这两个任务，这种情况就可以称之为并发。")]),t._v(" "),s("li",[t._v("并行是微观概念，假设 CPU 中存在两个核心，那么我就可以同时完成任务 A、B。同时完成多个任务的情况就可以称之为并行。")])]),t._v(" "),s("h2",{attrs:{id:"_13-什么是回调函数-回调函数有什么缺点-如何解决回调地狱问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_13-什么是回调函数-回调函数有什么缺点-如何解决回调地狱问题"}},[t._v("#")]),t._v(" 13. 什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？")]),t._v(" "),s("p",[t._v("以下代码就是一个回调函数的例子：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("ajax(url, () => {\n    // 处理逻辑\n})\n")])])]),s("p",[t._v("回调函数有一个致命的弱点，就是容易写出回调地狱（Callback hell）。假设多个请求存在依赖性，可能会有如下代码：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("ajax(url, () => {\n    // 处理逻辑\n    ajax(url1, () => {\n        // 处理逻辑\n        ajax(url2, () => {\n            // 处理逻辑\n        })\n    })\n})\n")])])]),s("p",[t._v("以上代码看起来不利于阅读和维护，当然，也可以把函数分开来写：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("function firstAjax() {\n  ajax(url1, () => {\n    // 处理逻辑\n    secondAjax()\n  })\n}\nfunction secondAjax() {\n  ajax(url2, () => {\n    // 处理逻辑\n  })\n}\najax(url, () => {\n  // 处理逻辑\n  firstAjax()\n})\n")])])]),s("p",[t._v("以上的代码虽然看上去利于阅读了，但是还是没有解决根本问题。回调地狱的根本问题就是：")]),t._v(" "),s("ol",[s("li",[t._v("嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身")]),t._v(" "),s("li",[t._v("嵌套函数一多，就很难处理错误")])]),t._v(" "),s("p",[t._v("当然，回调函数还存在着别的几个缺点，比如不能使用 "),s("code",[t._v("try catch")]),t._v(" 捕获错误，不能直接 "),s("code",[t._v("return")]),t._v("。")]),t._v(" "),s("h2",{attrs:{id:"_14-settimeout、setinterval、requestanimationframe-各有什么特点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_14-settimeout、setinterval、requestanimationframe-各有什么特点"}},[t._v("#")]),t._v(" 14. setTimeout、setInterval、requestAnimationFrame 各有什么特点？")]),t._v(" "),s("p",[t._v("异步编程当然少不了定时器了，常见的定时器函数有 "),s("code",[t._v("setTimeout")]),t._v("、"),s("code",[t._v("setInterval")]),t._v("、"),s("code",[t._v("requestAnimationFrame")]),t._v("。最常用的是"),s("code",[t._v("setTimeout")]),t._v("，很多人认为 "),s("code",[t._v("setTimeout")]),t._v(" 是延时多久，那就应该是多久后执行。")]),t._v(" "),s("p",[t._v("其实这个观点是错误的，因为 JS 是单线程执行的，如果前面的代码影响了性能，就会导致 "),s("code",[t._v("setTimeout")]),t._v(" 不会按期执行。当然了，可以通过代码去修正 "),s("code",[t._v("setTimeout")]),t._v("，从而使定时器相对准确：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("let period = 60 * 1000 * 60 * 2\nlet startTime = new Date().getTime()\nlet count = 0\nlet end = new Date().getTime() + period\nlet interval = 1000\nlet currentInterval = interval\nfunction loop() {\n  count++\n  // 代码执行所消耗的时间\n  let offset = new Date().getTime() - (startTime + count * interval);\n  let diff = end - new Date().getTime()\n  let h = Math.floor(diff / (60 * 1000 * 60))\n  let hdiff = diff % (60 * 1000 * 60)\n  let m = Math.floor(hdiff / (60 * 1000))\n  let mdiff = hdiff % (60 * 1000)\n  let s = mdiff / (1000)\n  let sCeil = Math.ceil(s)\n  let sFloor = Math.floor(s)\n  // 得到下一次循环所消耗的时间\n  currentInterval = interval - offset\n  console.log('时：'+h, '分：'+m, '毫秒：'+s, '秒向上取整：'+sCeil, '代码执行时间：'+offset, '下次循环间隔'+currentInterval)\n  setTimeout(loop, currentInterval)\n}\nsetTimeout(loop, currentInterval)\n")])])]),s("p",[t._v("接下来看 "),s("code",[t._v("setInterval")]),t._v("，其实这个函数作用和 "),s("code",[t._v("setTimeout")]),t._v(" 基本一致，只是该函数是每隔一段时间执行一次回调函数。")]),t._v(" "),s("p",[t._v("通常来说不建议使用 "),s("code",[t._v("setInterval")]),t._v("。第一，它和 "),s("code",[t._v("setTimeout")]),t._v(" 一样，不能保证在预期的时间执行任务。第二，它存在执行累积的问题，请看以下伪代码")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("function demo() {\n  setInterval(function(){\n    console.log(2)\n  },1000)\n  sleep(2000)\n}\ndemo()\n")])])]),s("p",[t._v("以上代码在浏览器环境中，如果定时器执行过程中出现了耗时操作，多个回调函数会在耗时操作结束以后同时执行，这样可能就会带来性能上的问题。")]),t._v(" "),s("p",[t._v("如果有循环定时器的需求，其实完全可以通过 "),s("code",[t._v("requestAnimationFrame")]),t._v(" 来实现：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("function setInterval(callback, interval) {\n  let timer\n  const now = Date.now\n  let startTime = now()\n  let endTime = startTime\n  const loop = () => {\n    timer = window.requestAnimationFrame(loop)\n    endTime = now()\n    if (endTime - startTime >= interval) {\n      startTime = endTime = now()\n      callback(timer)\n    }\n  }\n  timer = window.requestAnimationFrame(loop)\n  return timer\n}\nlet a = 0\nsetInterval(timer => {\n  console.log(1)\n  a++\n  if (a === 3) cancelAnimationFrame(timer)\n}, 1000)\n")])])]),s("p",[t._v("首先 "),s("code",[t._v("requestAnimationFrame")]),t._v(" 自带函数节流功能，基本可以保证在 16.6 毫秒内只执行一次（不掉帧的情况下），并且该函数的延时效果是精确的，没有其他定时器时间不准的问题，当然你也可以通过该函数来实现 "),s("code",[t._v("setTimeout")]),t._v("。")])])}),[],!1,null,null,null);e.default=a.exports}}]);